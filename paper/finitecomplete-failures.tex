% ==========================================================================
\section{Finite Complete Test Suites for CSP Failures Refinement}
\label{sec:finitecompletefails}
% ==========================================================================

Here, we define our notion of tests for failures refinement, and then prove
completeness of our suite. Finally, we study to complexity of our approach by
identifying a bound on the number of tests we need in a complete suite.

% ==========================================================================
\subsection{Test Cases for Verifying CSP Failures Refinement}

% -------------------------------------------------------------------------
\subsubsection*{Test Definition and Basic Properties}

In the domain of process algebras, test cases are typically represented by
processes interacting concurrently with the
SUT~\cite{Hennessy:1988:ATP:50497}. Considering an (unknown) process that
represents the behaviour of the SUT, we say that tests synchronise with the
process for the SUT over its visible events and use some additional events
outside the SUT process's alphabet to express whether the test execution
passed or failed.
%%%, or if no verdict could be obtained.

For a given reference process $P$, its normalised transition graph
$$
G(P) = ( N, \ii n, \Sigma, t : N\times\Sigma \pfun N, r : N \fun \mathbb{P}\mathbb{P}(\Sigma)),
$$
and each integer $p\ge 0$, we define a test for failures refinement as shown
below. %%
%\begin{eqnarray}
%U_F(p) & = & U_F(p,\varepsilon)
%\\
%U_F(p,s) & = & \big( \Extchoice e:(\Sigma - [P/s]^0) @ e \then \efail\then \Stop \big)
%\label{eq:ufa}
%\\ & & \extchoice \nonumber
%\\ & & (\minaccs(P/s) = \{ \varnothing \})    \&   \big( \epass \then \Stop \big)
%\label{eq:ufb}
%\\ & & \extchoice \nonumber
%\\ & & (\#s < p) \& \big( \Extchoice e:[P/s]^0 @ e \then U_F(p,s.e) \big)
%\label{eq:ufc}
%\\ & & \extchoice \nonumber
%\\ & & (\#s = p \wedge \minhits(P/s)\neq\varnothing) \&  \nonumber
%\\ & & \taba \big( \Intchoice_{H\in\minhits(P/s)} ( \Extchoice e:H @ e \then \epass \then\Stop   )  \big)
%\label{eq:ufd}
%\end{eqnarray}
%
%
\begin{eqnarray}
\label{eq:UFP}
U_F(p) & = & U_F(p,0,\ii n)
\\
U_F(p,k,n) & = & \big(e:(\Sigma - [n]^0)  \then \efail\then \Stop \big)
\label{eq:ufa}
\\ & & \extchoice \nonumber
\\ & & (\minhits(n) =   \varnothing  )    \&   \big( \epass \then \Stop \big)
\label{eq:ufb}
\\ & & \extchoice \nonumber
\\ & & (k < p) \& \big(e:[n]^0   \then U_F(p,k+1,t(n,e) \big)
\label{eq:ufc}
\\ & & \extchoice \nonumber
\\ & & (k = p \wedge \minhits(n)\neq\varnothing) \&  \nonumber
\\ & & \taba \big( \Intchoice_{H\in\minhits(n)} (e:H   \then \epass \then\Stop   )  \big)
\label{eq:ufd}
\end{eqnarray}

% --------------------------------------------------------------------------
\subsubsection*{Explanation of the Test Definition}
A test is performed by running $U_F(p)$ concurrently with any SUT process
$Q$, synchronising over $\Sigma$. So, a \emph{test execution} is a trace of the
concurrent process
%\[
$Q\parallel[\Sigma] U_F(p)$.
%\]

It is assumed that the events $\efail$ and $\epass$, indicating a verdict
FAIL and PASS for the test execution, are not included in $\Sigma$. Since we
assume that $Q$ is free of livelocks, it is guaranteed that events $\efail$
or $\epass$ always become visible, if they are the only events $U_F(p)/s$ is
ready to engage in: if $U_F(p)/s$ can only produce $\epass$ or $\efail$, the
occurrence of these events can never be blocked due to a livelock in $Q$
occurring in the same step of the execution.


The test is \emph{passed} by the SUT (written $Q\ \pass\ U_F(p)$) if, and
only if, {\it every} execution of $Q\parallel[\Sigma] U_F(p)$ terminates with
the event $\epass$. This can also be  expressed by means of a failures
refinement as defined below.
%
\begin{equation}
\label{eq:passF}
Q\ \pass\ U_F(p) \defs (\epass\then\Stop) \lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma
\end{equation}
%
This type of pass relation is often called \emph{must test} in the
literature, because every test execution must end with the $\epass$
event~\cite{Hennessy:1988:ATP:50497}.

We note that it is necessary to use failures refinement in the definition
above, and not just trace refinement:~$(Q\parallel[\Sigma] U_F(p)) \hide
\Sigma$ may have the same visible traces $\varepsilon$ and $\epass$ as the
``Test Passed Process'' $(\epass\then\Stop)$. However, the former may
nondeterministically refuse $\epass$, due to a deadlock occurring when a
faulty SUT process executes concurrently with $U_F(p,k,n)$ executing
branch~(\ref{eq:ufd}), when the guard condition $(k = p\wedge
\minhits(n)\neq\varnothing)$ evaluates to $\ist$. This is explained further
in the next paragraphs.

Intuitively speaking, $U_F(p)$ is able to perform any trace $s$ of $P$, up to
a length $p$. If, after having already run through $s\in\trc(P)$ with $\#s
\le p$, an event is accepted by the SUT that is outside the initials of $P/s$
 (recall from Lemma~\ref{lemma:ufproperties} that $[n]^0 = [P/s]^0$ for $U_F(p)/s$),
the test immediately terminates with FAIL-event $\efail$. This is handled by
the branch (\ref{eq:ufa}) of the external choice. %in the process
%$U_F(p,\#s,n)$ defined above.

If $P/s$ is the $\Stop$ process or has $\Stop$ as an internal choice, this is
revealed by $\minhits(G(P)/s) = \varnothing$ (recall
(\ref{eq:minhitminaccempty}) and Lemma~\ref{lemma:ufproperties}). In this
case, the test may terminate successfully (branch (\ref{eq:ufb}) of the
external choice in $U_F(p,\#s,G(P)/s)$). If $P/s$ may also
nondeterministically engage into events in such a situation, branch
(\ref{eq:ufc}) of the test is simultaneously enabled. If $Q/s$ is able to
engage into an event from $\Sigma - [P/s]^0$, a test execution exists where
$U_F(p,\#s,G(P)/s)$ branches into (\ref{eq:ufa}) and produces the $\efail$
event.

If the length of $s$ is still less than $p$, the test accepts any event $e$
from the initials $[P/s]^0 = [G(P)/s]^0$ and continues recursively as
$U_F(p,\#s+1,G(P)/s.e)$ in branch~(\ref{eq:ufc}); this follows again from
Lemma~\ref{lemma:ufproperties}. A test of this type is called
\emph{adaptive}, because it accepts any legal behaviour of the SUT and adapts
its consecutive behaviour to the event selected by the SUT.

Finally, we suppose that a test execution has run through a trace
$s\in\trc(P)$ of length $p$, so that $U_F(p)/s = U_F(p,p,n)$ with $n =
G(P)/s$. If $\minhits(n)\neq \varnothing$, the test changes its
behaviour:~instead of offering {\it all} legal events from $[n]^0$ to the
SUT, it nondeterministically chooses a minimal hitting set $H\in \minhits(n)$
and only offers the events contained in $H$. If the SUT refuses to engage
into some event of $H$, this reveals a violation of failures
refinement:~according to Lemma~\ref{lemma:hseta}, a conforming SUT should
accept at least one event of each minimal hitting set in $\minhits(n)$.
Therefore, the test execution only terminates with  $\epass$, if such an
event is accepted by the SUT. Otherwise, it deadlocks.

The specification of $U_F(p,k,n)$ implies that the test always stops after
having engaged into a trace $s\in\trc(Q)$ of maximal length $p$ or $p+1$. If
branch (\ref{eq:ufa}) is the last to be entered, the maximal length of $s$ is
$p+1$, and the test execution stops with $\efail$. If branch (\ref{eq:ufb})
is the last to be entered, the maximal length of $s$ is $p$, and the
execution stops with $\epass$. If branch (\ref{eq:ufd}) is the last to be
entered, the process either accepts another event $e$ of some minimal hitting
set $H\in\minhits(n)$ with $n = G(P)/s$ according to
Lemma~\ref{lemma:ufproperties}. Then the final length of $s$ is $p+1$, and
the execution terminates with $\epass$. Or the test execution
$(Q\parallel[\Sigma] U_F(p))/s$ deadlocks,  the final length of $s$ is $p$,
and the execution stops without a PASS or FAIL event. Such an execution is
also interpreted as FAIL, because it reveals that $(\epass\then\Stop)
\not\lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma$.

We observe that the number of possible executions of $Q\parallel[\Sigma]
U_F(p)$ is finite, because the number of traces $s$ with maximal length
$(p+1)$ is finite and the sets $[n]^0$, $(\Sigma - [n]^0)$, and $\minhits(n)$
are finite. Moreover, we further recall that $\minhits(n)$ may be empty, in
which case the indexed internal choice in (\ref{eq:ufd}) would be undefined.
The guard in that branch, however, requires $\minhits(n)\neq\varnothing$, and
branches (\ref{eq:ufa}) or (\ref{eq:ufb}) can be taken in this situation.

%Before explaining the intuition behind this test definition in the paragraphs
%below, we state its basic properties in the following lemma, to show the
%relationships between $U_F(p)$ and the reference process $P$ from which the
%former has been derived. \fixme{For a reader, it is better to see the
%explanation first. Since this is easier to undo, I've changed it. }

We state basic properties of our tests in the following lemma, to show the
relationships between $U_F(p)$ and the reference process $P$ from which it is
derived.

\begin{lemma}\label{lemma:ufproperties}
If $s\in\trc(P)$ satisfies $\#s\le p$, then
$s, s.e\in\trc(U_F(p))$ for all $e\in\Sigma$, and the following properties hold.
\begin{eqnarray}
\label{eq:ifpa}
  &  & U_F(p)/s = U_F(p,\#s,G(P)/s)
\\
\label{eq:ifpb}
e\not\in [P/s]^0 & \implies & U_F(p)/s.e = (\efail\then\Stop)
\\
\label{eq:ifpc}
U_F(p)/s = U(p,\# s,n)  & \implies & [n]^0 = [P/s]^0
\\
\label{eq:ifpd}
U_F(p)/s = U(p,\# s,n)  & \implies & \minhits(n) = \minhits(P/s)
\end{eqnarray}
\end{lemma}
\begin{proof}
We prove (\ref{eq:ifpa}) by induction over the length of $s$. For $\#s = 0$,
the statement holds because $U_F(p)$ starts with the initial node $\ii n$ of
$G(P)$. Suppose that the statement holds for all traces $s$ with length $\# s
\le k < p$, so that $U_F(p)/s = U_F(p,\#s,G(P)/s)$. Now let $s.e$ be a trace
of $P$, so that $e\in [P/s]^0$. Since $[G(P)/s]^0 = [P/s]^0$ for all traces
$s$ of $P$, we conclude that $e\in  [G(P)/s]^0$, so $U_F(p,\#s,G(P)/s)$ can
engage into $e$ by executing branch (\ref{eq:ufc}). Since $t$ is the
transition function of $G(P)$ and $e\in [G(P)/s]^0$, $t(G(P)/s,e)$ is
defined, and $t(G(P)/s,e) = G(P)/s.e$. This leads to a new recursion, so that
$U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = U_F(p,\#s+1,G(P)/s.e)$ as required.

To prove (\ref{eq:ifpb}), we apply (\ref{eq:ifpa}) to conclude that $U_F(p)/s
= U_F(p,\#s,G(P)/s)$, because $s$ is a trace of $P$. Noting again that
$[G(P)/s]^0 = [P/s]^0$, this implies that $e\not\in [G(P)/s]^0$, so
$U_F(p,\#s,G(P)/s)$ can engage in $e$ by entering branch (\ref{eq:ufa}). The
specification of this branch implies that
$$
U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = (\efail\then\Stop).
$$
%
Statement (\ref{eq:ifpc}) follows trivially from (\ref{eq:ifpa}), because
$[G(P)/s]^0 = [P/s]^0$ for all traces $s$ of $P$. Finally, statement
(\ref{eq:ifpd}) follows trivially from (\ref{eq:ifpa}), because, according to
(\ref{eq:minhitsGP}), $\minhits(G(P)/s) = \minhits(P/s)$ for all traces of
$P$. \xbox
\end{proof}
%
Note that it is not guaranteed for $U_F(p)$ to run through the traces $s,
s.e$ in Lemma~\ref{lemma:ufproperties}, if $\minhits(P/u) = \varnothing$ for
some prefix $u$ of $s$: in such a case, $U_F(p)$ may stop with a $\epass$
event by entering branch (\ref{eq:ufb}). Therefore,
Lemma~\ref{lemma:ufproperties} just states the existence of
$U_F(p)$-executions $s, s.e$ satisfying the properties stated there.

% =========================================================================
\subsection{A Finite Complete Test Suite for Failures Refinement}
% =========================================================================

A CSP \emph{fault model} ${\cal F} = (P,\sqsubseteq,{\cal D})$ consists of a
reference process $P$, a conformance relation $\sqsubseteq \in \{\lessdet_T,
\lessdet_F\}$, and a fault domain ${\cal D}$, which is a set of CSP processes
over $P$'s alphabet that may or may not conform to $P$.

A test suite $\TS$ is called \emph{complete} with respect to fault model
${\cal F}$, if, and only if, the following conditions are fulfilled.
\begin{description}
\item[1.~Soundness] If $P \sqsubseteq Q$, then $Q$ passes all tests in $\TS$.
\item[2.~Exhaustiveness] If $P \not\sqsubseteq Q$ and $Q\in{\cal D}$,
then $Q$ fails at least one test in $\TS$.
\end{description}
%
The following main theorem establishes the completeness of our test suite.

\begin{theorem}\label{th:failurestest}
Let $P$ be a non-terminating, divergence-free CSP process over alphabet $\Sigma$ whose
normalised transition graph $G(P)$ has $p$ states. Define fault domain ${\cal
D}$ as the set of all divergence-free CSP processes over alphabet $\Sigma$,
whose transition graph has at most $q$ states with $q \ge p$. Then the test
suite
\[
\TS_F = \{ U_F(k)~|~0 \le k < pq  \}\quad\text{$U_F(k)$ specified in (\ref{eq:UFP})}
\]
is complete with respect to ${\cal F} = (P,\lessdet_F,{\cal D})$.
\end{theorem}
%
The proof of the theorem follows from the two lemmas below. The first states
that test suite $\TS_F$ is sound, the second states that the suite is also
exhaustive.
%
\begin{lemma}\label{lemma:mainfsound}
A test suite $\TS_F$ generated from a CSP process $P$, as specified in
Theorem~\ref{th:failurestest}, is passed by every CSP process $Q$ satisfying
$P\lessdet_F Q$.
\end{lemma}
\begin{proof}{~}We make two points in separate steps below. The
first is that the test execution cannot reach branch~(\ref{eq:ufa}) and raise
a $fail$ event.  The second is that it cannot deadlock without raising a
$pass$ event. This case would also be interpreted as FAIL, since then
$\epass\then\Stop$ is not failures refined by $(Q\parallel[\Sigma]
U_F(k))\hide \Sigma$.
% alcc: part of the explanation above was in the following lemma, but it is already
% relevant here.

\paragraph{Step~1.} Suppose that $P\lessdet_F Q$, so $P\lessdet_T Q$ and $Q\
conf\ P$ according to (\ref{eq:failconf}). Since   $\trc(Q)\subseteq
\trc(P)$, any adaptive test $U_F(p)$ running in parallel with $Q$ will always
enter the branches (\ref{eq:ufb}), (\ref{eq:ufc}), or (\ref{eq:ufd}) of the
external choice construction for $U_F(p,k,n)$. If $U_F(p,k,n) = U_F(p)/s$
with $s\in\trc(P)$, then Lemma~\ref{lemma:ufproperties} implies $U_F(p,k,n) =
U_F(p,k,G(P)/s)$, so $[n]^0 = [G(P)/s]^0 = [P/s]^0$. As a consequence,
$[Q/s]^0\subseteq [P/s]^0 = [n]^0$, so branch~(\ref{eq:ufa}) can never be
entered in the parallel execution of $Q$ and $U_F(p)$, and the $fail$ event
cannot occur.

\paragraph{Step~2.} Since $Q\ conf\ P$, Lemma~\ref{lemma:hseta} implies
that for all $s\in\trc(Q)\cap\trc(P)$, every $H \in \minhits(P/s)$ is a
hitting set for $\minaccs(Q/s)$. From Lemma~\ref{lemma:ufproperties} we know
that $U_F(p)/s = U_F(p,k,n)$ with $U_F(p,k,n) = U_F(p,\#s,G(P)/s)$, so
$\minhits(n) = \minhits(P/s)$. The branch (\ref{eq:ufb}) of the test
$U_F(p,k,n)$ leads always to a PASS verdict and is taken if $\minhits(n) =
\varnothing$. The branch (\ref{eq:ufc}) always leads to test continuation
without a verdict. \fixme{I think we need a stronger argument here, as to why
it cannot deadlock.}
\fxnote{jp: I do not understand the question -- let's discuss this on the phone.}
 For the last branch, we note that it can only be entered
if $\minhits(P/s) = \minhits(n) \neq\varnothing$. In this case, any selected
minimal hitting set $H\in\minhits(n)$ has a non-empty intersection with each
of the minimal acceptances of $Q/s$. As a consequence, $Q/s$ never blocks
when offered events from $H\in\minhits(n)$, and the test terminates with
event $\epass$. Note that this argument requires that $Q$ is free of
livelocks, because otherwise the $\epass$-events might not become visible,
due to unbounded sequences of hidden events performed by $Q$. \xbox
\end{proof}
%
\begin{lemma}\label{lemma:mainfexhaustive}
A test suite $\TS_F$ specified as in Theorem~\ref{th:failurestest} is
exhaustive for the fault model specified there and for conformance relation $\lessdet_F$.
\end{lemma}
\begin{proof}
Consider a process $Q\in{\cal D}$ with $P\not\lessdet_F Q$. According to
(\ref{eq:failconf}), this non-conformance can be caused in two possible ways
corresponding to the cases $P\not\lessdet_T Q$ and $\neg(Q\ conf\ P)$. These
cases can be characterised as follows:
\begin{description}
\item[Case~1] $\trc(Q)\not\subseteq \trc(P)$
\item[Case~2] There exists a joint trace $s\in\trc(Q)\cap\trc(P)$ and a minimal acceptance $A_Q$
of $\minaccs(Q/s)$, such that
(see Lemma~\ref{lemma:tgtrcref}, (\ref{eq:failrefb})).
\begin{equation}
\label{eq:accsnotcontained}
\forall A_P\in\minaccs(P/s): A_P\not\subseteq A_Q,
\end{equation}
\end{description}
It has to be shown for each of these cases that at least one test execution
of some $(Q\parallel[\Sigma] U_F(k))$ with $k < pq$ ends with the $\efail$
event or deadlocks. We do this by analysing the product graph of the reference
process $P$ and the SUT process $Q$: any trace $s\in\trc(Q)\cap\trc(P)$ gives rise to 
a path labelled by the events of $s$ 
through this product graph. Any error can be detected after running through such a trace
and then either observing an event outside $[P/s]^0$ (this is the violation described
by Case~1) or identifying an illegal acceptance $A_Q$ as specified in Case~2. 
It is not guaranteed, however, that trace $s$ is short enough to be executed by one of the 
test cases $U_F(p)$. Therefore, it has to be shown that for any $s$ leading to an error
situation specified by Case~1 or Case~2, there exists a trace $u$ of maximal length $pq-1$
leading to the same error.



\medskip
\noindent {\bf Case~1.} 
\fixme{There is an assumption here that
the graph of a test execution is given by the cross-product of graphs.  But,
test execution is not defined in this way. It is defined by parallelism and
hiding. I think the definition of test execution needs to change.}
\fxnote{jp: this is a misunderstanding: we are not looking at the product graph of $Q$ and $U_F(p)$, but at the product graph of $Q$ and $P$. I have added more explanatory 
text in the paragraph  before Case~1.}
Consider a  trace $s.e\in\trc(Q)$ with $s\in\trc(P)$,
but $s.e\not\in\trc(P)$. Such a trace always exists because $\varepsilon$ is
a trace of every process. In this case, $s$ is also a trace of the product
graph $G = G(P)\times G(Q)$ defined in Section~\ref{sec:ntg}, and $G/s =
(G(P)/s,G(Q)/s)$ holds. The length of $s$ is not known, but from the
construction of $G$,  we know that $G$ has at most $pq$ reachable states,
because $G(P)$ has $p$ states, and $G(Q)$ has at most $q$ states. By
Lemma~\ref{lemma:reachproduc}, $(G(P)/s,G(Q)/s)$ can be reached by a trace
$u\in\trc(G)$ of length $\#u < pq$. Now the construction of the transition
function of $G$ implies that $u$ is also a trace of $P$ and $Q$, which means
that $(G(P)/s,G(Q)/s) = (G(P)/u,G(Q)/u)$. Since test $U_F(pq-1)$ accepts all
traces of $P$ up to length $pq-1$, $u$ is also a trace of this test, and, by
construction and by Lemma~\ref{lemma:ufproperties}, $U_F(pq-1)/u =
U_F(pq-1,\#u,G(P)/u)$. Since $s.e\not\in\trc(P)$, $e$ is an element of
$\Sigma-[P/u]^0 = \Sigma - [G(P)/s]^0$. Hence, in at least one execution,
$U_F(pq-1,\#u,G(P)/u)$ executes its first branch (\ref{eq:ufa}) with this
event $e$, so that the test fails. Again, the assumption of non-divergence of
$Q$ is needed for this conclusion. 

\medskip
\noindent {\bf Case~2.} We note 
\fixme{Again, nothing here is about this process, but about the graph, and
the hiding that is needed is discarded.} 
\fxnote{jp: see my explanation above}
that trace $s$ is again a trace of the
product graph $G$, but we do not know its length. Again, by applying
Lemma~\ref{lemma:reachproduc}, we know that the state $G/s$ can be reached by
a trace $u\in\trc(Q)\cap\trc(P)$ of maximal length $\#u < pq$. We consider
the test $U_F(\# u)$, for which $U_F(\# u)/u = U_F(\#u,\#u,G(P)/u)$, because
of Lemma~\ref{lemma:ufproperties}. Test $U_F(\#u)$   always performs branch
(\ref{eq:ufc}) until the trace $u$ has been completely processed.
$U_F(\#u,\#u,G(P)/u)$ may execute branches (\ref{eq:ufa}) or (\ref{eq:ufd})
only:~assumption (\ref{eq:accsnotcontained}) in Case~2 implies that $P/s$ has
at least one non-empty minimal acceptance. From (\ref{eq:minhitminaccempty})
we know that this is equivalent to $\minhits(P/s) =
\minhits(G(P)/s)\neq\varnothing$, and we observe that $G(P)/s = G(P)/u$, so
$\minhits(G(P)/u)\neq\varnothing$. As a consequence, branch (\ref{eq:ufb})
cannot be taken because its guard condition evaluates to $\isf$  for
$U_F(\#u,\#u,G(P)/u)$. The guard condition $(k < p)$ for branch
(\ref{eq:ufc}) evaluates to $\isf$ for $U_F(\#u,\#u,G(P)/u)$, too. If branch
(\ref{eq:ufa}) is executed, the test always fails. If branch (\ref{eq:ufd})
is executed, the test fails for the execution where a minimal hitting set
$H\in\minhits(P/u)$ is chosen by $U_F(\#u,\#u,G(P)/u)$ that has an empty
intersection with the minimal acceptance $A_Q$ from condition
(\ref{eq:accsnotcontained}). The existence of such an $H$ is guaranteed
because of Lemma~\ref{lemma:hseta}. As a consequence, there exists a test
execution   where $Q/u$ selects acceptance $A_Q$ and $U_F(\#u,\#u,G(P)/u)$
selects $H$. This execution deadlocks in process state
$(Q\parallel[\Sigma]U_F(\# u))/u$, so it cannot produce the $\epass$-event;
this means that the test fails. This
concludes the proof. 
\xbox
\end{proof}
%
Our notion of tests can be specialised to deal with traces refinement, as we
explain in Section~\ref{sec:finitecomplete}. 
The next section presents and example.
\fixme{I think
the example should come before more theory.}
\fxnote{jp: done}

% ==========================================================================
