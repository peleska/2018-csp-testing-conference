% ==========================================================================
\section{Finite Complete Test Suites for CSP Failures Refinement}
\label{sec:finitecompletefails}
% ==========================================================================


% ==========================================================================
\subsection{Test Cases for Verifying CSP Failures Refinement}

In the domain of process algebras, test cases are typically represented 
by processes interacting concurrently with the SUT 
process~\cite{Hennessy:1988:ATP:50497}. They synchronise with the SUT over its visible events and use some additional events outside the SUT's alphabet to express whether the test execution  passed or failed. %%%, or if no verdict could be obtained.

For a given reference process $P$ and for each integer $p\ge 0$, we define a
CSP test process for failures refinement as shown below.
%
\begin{eqnarray}
U_F(p) & = & U_F(p,\varepsilon)
\\
U_F(p,s) & = & \big( \Extchoice e:(\Sigma - [P/s]^0) @ e \then \efail\then \Stop \big)
\label{eq:ufa}
\\ & & \extchoice \nonumber
\\ & & ([P/s]^0 = \varnothing)    \&   \big( \epass \then \Stop \big)
\label{eq:ufb}
\\ & & \extchoice \nonumber
\\ & & (\#s < p) \& \big( \Extchoice e:[P/s]^0 @ e \then U_F(p,s.e) \big)
\label{eq:ufc}
\\ & & \extchoice \nonumber
\\ & & (\#s = p) \& \big( \sqcap_{H\in\text{minHit}(P/s)} ( \Extchoice e:H @ e \then \epass \then\Stop   )  \big)
\label{eq:ufd}
\end{eqnarray}
%
A test is performed by running $U_F(p)$ concurrently with any SUT process $Q$,
synchronising over alphabet $\Sigma$. Therefore, a test execution is any
trace of the concurrent process
\[
Q\parallel[\Sigma] U_F(p).
\]
It is assumed that the events $\efail$ and $\epass$, denoting FAIL and PASS
of the test execution, are events outside $\Sigma$. Since we assume that $Q$
is free of livelocks, it is guaranteed that each test execution terminates
after some $s\in\trc(P)$ with length $(p+1)$ at the latest. The test is
\emph{passed} by the SUT (written $Q\ \pass\ U_F(p)$) if, and only if, {\it
every} execution of $Q\parallel[\Sigma] U_F(p)$ terminates with PASS event
$\epass$. This can also be  expressed by means of a failures refinement.
\[
Q\ \pass\ U_F(p) \defs (\epass\then\Stop) \lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma
\]
This type of pass relation is often called \emph{must test}, because every
test execution must end with the $\epass$
event~\cite{Hennessy:1988:ATP:50497}. Note that it is necessary to use the
failures-refinement relation in this condition, and not the trace-refinement
relation:~$(Q\parallel[\Sigma] U_F(p)) \hide \Sigma$ may have  the same
visible traces $\varepsilon$ and $\langle \epass\rangle$ as the ``Test Passed
Process'' $(\epass\then\Stop)$. However, the former may nondeterministically
refuse $\epass$, due to a deadlock occurring when a faulty SUT process
executes concurrently with $U_F(p,s)$ executing branch (\ref{eq:ufd}),
because $\#s = p$. This is explained further in the next paragraphs.

Observe that the number of possible executions of $Q\parallel[\Sigma] U_F(p)$ is finite,
because the number of traces $s$ with maximal length $(p+1)$ is finite and the 
sets $[P/s]^0$, $(\Sigma - [P/s]^0)$, and $\text{minHit}(P/s)$ are finite.

Intuitively speaking, $U_F(p)$ is able to perform any trace $s$ of $P$, up to
a length $p$. If, after having already run through $s\in\trc(P)$ with $\#s <
p$, an event is accepted by the SUT that is outside the initials of $P/s$,
the test immediately terminates with FAIL-event $\efail$. This is handled by
the branch (\ref{eq:ufa}) of the external choice in the process $U_F(p,s)$
defined above.

If $P/s$ is the $STOP$ process, this is revealed by its initials being empty.
In this case, the test may terminate successfully (branch (\ref{eq:ufb}) of
the external choice in $U_F(p,s)$). Note that at the same time, any (illegal)
event of the alphabet is also accepted by the test in branch~(\ref{eq:ufa}).
So, if the SUT accepts an event in a state where $P/s$ is supposed to have
stopped, there exists a test execution that terminates with FAIL by choosing
the first branch of the external choice.

If the length of $s$ is still less than $p$, the test accepts any event from
the initials $[P/s]^0$ and continues recursively as $U_F(p,s.e)$ in
branch~(\ref{eq:ufc}). A test of this type is called \emph{adaptive}, because
it accepts any legal behaviour of the SUT and adapts its consecutive
behaviour to the event selected by the SUT.

After having  run successfully
through a trace of length $p$, the test changes its behaviour:
instead of offering {\it all} legal events from $[P/s]^0$ to the SUT,
it nondeterministically chooses
a minimal hitting set of $\minaccs(P/s)$ and only offers the events contained in this set.
If the SUT refuses to engage into any of these events, this reveals a violation of the
failures refinement: according to Lemma~\ref{lemma:hseta}, a conforming SUT should accept
at least one event of each minimal hitting set in $\text{minHit}(P/s)$. Therefore, the test
only terminates with success $\epass$, if such an event is accepted by the SUT.



% =========================================================================
\subsection{Fault Models and Complete Test Suites}

A \emph{fault model} ${\cal F} = (P,\sqsubseteq,{\cal D})$ consists of a reference process
$P$, a conformance relation $\sqsubseteq \in \{\lessdet_T, \lessdet_F\}$, and a fault domain 
${\cal D}$ which is a set of CSP processes over $P$'s alphabet that may or may not conform to $P$.

A test suite $\TS$ is called \emph{complete} with respect to fault model ${\cal F}$,
if and only of the following conditions are fulfilled.
\begin{description}
\item[1.~Soundness] If $P \sqsubseteq Q$, then $Q$ passes all tests in $\TS$.
\item[2.~Exhaustiveness] If $P \not\sqsubseteq Q$ and $Q\in{\cal D}$, 
then $Q$ fails at least one test in $\TS$.
\end{description} 


% =========================================================================
\subsection{A Finite Complete Test Suite for Failures Refinement}

After the informal explanation of tests representing adaptive test cases, we are ready to state the main theorem of this paper.

\begin{theorem}\label{th:failurestest}
Let $P$ be a divergence-free CSP process over alphabet $\Sigma$
whose normalised transition graph $G(P)$ has $p$ states. Define fault domain ${\cal D}$ as
the set of all divergence-free CSP processes over alphabet $\Sigma$, whose transition graph
has at most $q$ states with $q \ge p$.
Then the test suite
\[
\TS_F = \{ U_F(k)~|~0 \le k < pq  \}
\]
is complete with respect to ${\cal F} = (P,\lessdet_F,{\cal D})$.
\end{theorem}


The proof of the theorem follows from the two lemmas below. The first states that test
suite $\TS_F$ is sound, the second states that the suite is also exhaustive.

\begin{lemma}\label{lemma:mainfsound}
Test suite $\TS_F$ generated from CSP process $P$, as specified in Theorem~\ref{th:failurestest}, is passed by
every CSP process $Q$ satisfying $P\lessdet_F Q$.
\end{lemma}
\begin{proof}
Suppose that $P\lessdet_F Q$, so $P\lessdet_T Q$ and  $P\ conf\ Q$ 
according to (\ref{eq:failconf}). 
Since   $\trc(Q)\subseteq
\trc(P)$,   any adaptive test
$U_F(p)$ running in parallel with $Q$ will always enter the branches (\ref{eq:ufb}), (\ref{eq:ufc}), or
(\ref{eq:ufd}) of the external choice construction for $U_F(p,s)$.
Branch~(\ref{eq:ufa}) can never be entered in the parallel execution of $Q$
and $U_F(p)$, because $[Q/s]^0\subseteq [P/s]^0$ for all traces of $Q$.

Moreover,  Lemma~\ref{lemma:hseta}
implies that for all traces $s\in\trc(Q)\cap\trc(P)$, every $H$ in $\text{minHit}(P/s)$ is
a hitting set for $\minaccs(Q/s)$. Branch (\ref{eq:ufb}) of test $U_F(p,s)$ 
leads always to a PASS verdict, and branch
(\ref{eq:ufc}) to test continuation without a verdict. For the last branch,
we note that any selected minimal hitting set $H\in\text{minHit}(P/s)$ has a
non-empty intersection with each of the minimal acceptances of $Q/s$. As a
consequence, $Q/s$ never blocks when offered events from $H$, and the test
terminates with PASS event $\epass$. Note that this argument requires that
$Q$ is free of livelocks, because otherwise the PASS-events might not become
visible, due to unbounded sequences of hidden events performed by $Q$.
%Note
%further, that this proof did not refer in any way to the size of $Q$'s
%normalised transition graph, so the test suite is sound for {\it all}
%non-divergent CSP process refining $P$.
%\fixme{alcc: Soundness does not
%depend on the fault domain. I would have it as a separate theorem.}
%\fxnote{jp: this is a good idea, I have split the proof of the main theorem in 2 lemmas.}
\xbox
\end{proof}

\begin{lemma}\label{lemma:mainfexhaustive}
Test suite $\TS_F$ specified im Theorem~\ref{th:failurestest} is exhaustive for the fault
model specified there.
\end{lemma}
\begin{proof}
Consider a process $Q\in{\cal D}$ with
$P\not\lessdet_F Q$, According to (\ref{eq:failconf}),  
this non-conformance can be caused in two possible ways corresponding to the cases $P\not\lessdet_T Q$ and 
$\neg(P\ conf\ Q)$, respectively:
\begin{description}
\item[Case~1] $\trc(Q)\not\subseteq \trc(P)$
\item[Case~2] There exists a joint trace $s\in\trc(Q)\cap\trc(P)$ and a minimal acceptance $A_Q$
of $\minaccs(Q/s)$, such that
(see Lemma~\ref{lemma:tgtrcref}, (\ref{eq:failrefb})).
\begin{equation}
\label{eq:accsnotcontained}
\forall A_P\in\minaccs(P/s): A_P\not\subseteq A_Q,
\end{equation}
\end{description}
It has to be shown for each of the two possibilities that at least one test
execution of some $(Q\parallel[\Sigma] U_F(k))$ with $k < pq$ ends with the
FAIL event $\efail$ or without giving any verdict. The latter case is also
interpreted  as FAIL, since then the process $\epass\then\Stop$ is no longer
failures-refined by the test execution.

For Case~1, consider a  trace $s.e\in\trc(Q)$ such that $s\in\trc(P)$, but
$s.e\not\in\trc(P)$. Such a trace always exists because $\varepsilon$ is a
trace of every process. In this case, $s$ is also a trace of the product
graph $G = G(P)\times G(Q)$ defined in Section~\ref{sec:ntg}. Suppose that
$G/s = (n_P,n_Q)$. The length of $s$ is not known, but from the construction
of $G$,  we know that $G$ has at most $pq$ reachable states, because $G(P)$
has $p$ states, and $G(Q)$ has at most $q$ states. By
Lemma~\ref{lemma:reachproduc}, $(n_P,n_Q)$ can be reached by a trace
$u\in\trc(G)$ of length $\#u < pq$. Now the construction of the transition
function of $G$ implies that $u$ is also a trace of $P$ and $Q$. Since test
$U_F(pq-1)$ accepts all traces of $P$ up to length $pq-1$, $u$ is also a
trace of this test, and, by construction, $U_F(pq-1)/u = U_F(pq-1,u)$. Since
$s.e\not\in\trc(P)$, $e$ is an element of $\Sigma-[P/u]^0$. So, in at least
one execution, $U_F(pq-1,u)$ executes its first branch (\ref{eq:ufa}) with
this event $e$, so that the test fails. Again, the
assumption of non-divergence of Q is needed for this conclusion. %\fixme{alcc:
%I didn't see how Lemma 3 is being applied here. Also, given the definition of
%the test as a process, I'm not sure why you need to make the argument using
%graph product.}
%\fxnote{jp: I do hope that this is now clearer from the new structure of the lemmas}

For   Case~2, we note that trace $s$ is again a trace of the product graph
$G$, but we do not know its length. Again, by applying Lemma~\ref{lemma:reachproduc},
we know that the state   $G/s$ can   be reached by a trace
$u\in\trc(Q)\cap\trc(P)$ of maximal length $\#u < pq$. Consider test $U_F(\#
u)$, which satisfies $U_F(\# u)/u = U_F(\#u,u)$, because it always performs
branch (\ref{eq:ufc}) until the trace $u$ has been completely processed.
$U_F(\#u,u)$ may execute branches (\ref{eq:ufa}) or (\ref{eq:ufd})
only:~assumption (\ref{eq:accsnotcontained}) in Case~2 implies that $P/s$ has
at least one non-empty minimal acceptance, so the guard condition $([P/s]^0 =
\varnothing)$ of branch (\ref{eq:ufb}) evaluates to $\isf$ for $U_F(\#u,u)$.
Moreover, the guard condition $(\#s < p)$ for branch (\ref{eq:ufc}) evaluates
to $\isf$ for $U_F(\#u,u)$, too. If branch (\ref{eq:ufa}) is executed, the
test always fails. If branch (\ref{eq:ufd}) is executed, the test fails for
the execution where a minimal hitting set $H\in\text{minHit}(P/u)$ is chosen
by $U_F(\#u,u)$ that has an empty intersection with the minimal acceptance
$A_Q$ from condition (\ref{eq:accsnotcontained}). The existence of such an
$H$ is guaranteed because of Lemma~\ref{lemma:hseta}. As a consequence, there
exists a test execution   where $Q/u$ selects acceptance $A_Q$ and
$U_F(\#u,u)$ selects $H$. This execution deadlocks in process state
$(Q\parallel[\Sigma]U_F(\# u))/u$, so it cannot produce the pass event
$\epass$; this  means that the test fails. This concludes the proof. \xbox
\end{proof}


















% ==========================================================================
