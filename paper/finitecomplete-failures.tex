% ==========================================================================
\section{Finite Complete Test Suites for CSP Failures Refinement}
\label{sec:finitecompletefails}
% ==========================================================================

Here, we define our notion of tests for failures refinement, and then prove
completeness of our suite. Finally, we study to complexity of our approach by
identifying a bound on the number of tests we need in a complete suite.

% ==========================================================================
\subsection{Test Cases for Verifying CSP Failures Refinement}

% -------------------------------------------------------------------------
\subsubsection*{Test Definition and Basic Properties}
In the domain of process algebras, test cases are typically represented
by processes interacting concurrently with the SUT
process~\cite{Hennessy:1988:ATP:50497}. They synchronise with the SUT over its visible events and use some additional events outside the SUT's alphabet to express whether the test execution  passed or failed. %%%, or if no verdict could be obtained.

For a given reference process $P$, its normalised transition graph 
$$
G(P) = ( N, \ii n, \Sigma, t : N\times\Sigma \pfun N, r : N \fun \mathbb{P}\mathbb{P}(\Sigma)),
$$ 
and for each integer $p\ge 0$, we define a
CSP test process for failures refinement as shown below.
%%
%\begin{eqnarray}
%U_F(p) & = & U_F(p,\varepsilon)
%\\
%U_F(p,s) & = & \big( \Extchoice e:(\Sigma - [P/s]^0) @ e \then \efail\then \Stop \big)
%\label{eq:ufa}
%\\ & & \extchoice \nonumber
%\\ & & (\minaccs(P/s) = \{ \varnothing \})    \&   \big( \epass \then \Stop \big)
%\label{eq:ufb}
%\\ & & \extchoice \nonumber
%\\ & & (\#s < p) \& \big( \Extchoice e:[P/s]^0 @ e \then U_F(p,s.e) \big)
%\label{eq:ufc}
%\\ & & \extchoice \nonumber
%\\ & & (\#s = p \wedge \minhits(P/s)\neq\varnothing) \&  \nonumber 
%\\ & & \taba \big( \Intchoice_{H\in\minhits(P/s)} ( \Extchoice e:H @ e \then \epass \then\Stop   )  \big)
%\label{eq:ufd}
%\end{eqnarray}
%
%
\begin{eqnarray}
\label{eq:UFP}
U_F(p) & = & U_F(p,0,\ii n)
\\
U_F(p,k,n) & = & \big(e:(\Sigma - [n]^0)  \then \efail\then \Stop \big)
\label{eq:ufa}
\\ & & \extchoice \nonumber
\\ & & (\minhits(n) =   \varnothing  )    \&   \big( \epass \then \Stop \big)
\label{eq:ufb}
\\ & & \extchoice \nonumber
\\ & & (k < p) \& \big(e:[n]^0   \then U_F(p,k+1,t(n,e) \big)
\label{eq:ufc}
\\ & & \extchoice \nonumber
\\ & & (k = p \wedge \minhits(n)\neq\varnothing) \&  \nonumber 
\\ & & \taba \big( \Intchoice_{H\in\minhits(n)} (e:H   \then \epass \then\Stop   )  \big)
\label{eq:ufd}
\end{eqnarray}
%
Before explaining the intuition behind this test definition in the paragraphs below,
we state its basic properties in the following lemma, to show the relationships between
$U_F(p)$ and the reference process $P$ from which the former has been derived.

\begin{lemma}\label{lemma:ufproperties}
If $s\in\trc(P)$ satisfies $\#s\le p$, then
$s, s.e\in\trc(U_F(p))$ for all $e\in\Sigma$, and the following properties hold.
\begin{eqnarray}
\label{eq:ifpa}
  &  & U_F(p)/s = U_F(p,\#s,G(P)/s)
\\
\label{eq:ifpb}
e\not\in [P/s]^0 & \implies & U_F(p)/s.e = (\efail\then\Stop)
\\
\label{eq:ifpc}
U_F(p)/s = U(p,\# s,n)  & \implies & [n]^0 = [P/s]^0  
\\
\label{eq:ifpd}
U_F(p)/s = U(p,\# s,n)  & \implies & \minhits(n) = \minhits(P/s)
\end{eqnarray}
\end{lemma}
\begin{proof}
We prove (\ref{eq:ifpa}) by induction over the length of $s$. For $\#s = 0$, the statement holds because $U_F(p)$ starts with the initial node $\ii n$ of $G(P)$. Suppose that 
the statement holds for all traces $s$ with length $\# s \le k < p$, so that
$U_F(p)/s = U_F(p,\#s,G(P)/s)$. Now let $s.e$ be a trace of $P$. Then $e\in [P/s]^0$. Since $[G(P)/s]^0 = [P/s]^0$ for all traces $s$ of $P$, we conclude that $e\in  [G(P)/s]^0$,
so $U_F(p)/s = U_F(p,\#s,G(P)/s)$ can engage into $e$ by executing branch (\ref{eq:ufc}).
 Since $t$ is the transition function of $G(P)$ and $e\in  [G(P)/s]^0$, $t(G(P)/s,e)$
 is defined, and $t(G(P)/s,e) = G(P)/s.e$ holds.
This leads to a new recursion  
$U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = U_F(p,\#s+1,G(P)/s.e)$ and proves the induction step.

To prove (\ref{eq:ifpb}), we apply (\ref{eq:ifpa}) to conclude that 
$U_F(p)/s = U_F(p,\#s,G(P)/s)$, because $s$ is a trace of $P$. Noting again that
$[G(P)/s]^0 = [P/s]^0$, this implies that $e\not\in [G(P)/s]^0$, so $U_F(p,\#s,G(P)/s)$
can engage in $e$ by entering branch (\ref{eq:ufa}). The specification of this branch
implies that 
$$
U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = (\efail\then\Stop).
$$

Statement (\ref{eq:ifpc}) follows trivially from (\ref{eq:ifpa}), because 
$[G(P)/s]^0 = [P/s]^0$ for all traces $s$ of $P$.

Finally, statement (\ref{eq:ifpd}) follows trivially from (\ref{eq:ifpa}), because,
according to (\ref{eq:minhitsGP}),
$\minhits(G(P)/s) = \minhits(P/s)$ for all traces of $P$.
\xbox
\end{proof}

Note that it is not guaranteed for $U_F(p)$ to run through the traces $s, s.e$ specified 
in Lemma~\ref{lemma:ufproperties}, if $\minhits(P/u) = \varnothing$ for some prefix $u$ of $s$: in such a case, $U_F(p)$ may stop with a $\epass$-event by entering branch (\ref{eq:ufb}). Therefore, Lemma~\ref{lemma:ufproperties} just states the existence of
$U_F(p)$-executions $s, s.e$ satisfying the properties stated there.



% --------------------------------------------------------------------------
\subsubsection*{Explanation of the Test Definition}
A test is performed by running $U_F(p)$ concurrently with any SUT process
$Q$, synchronising over $\Sigma$. So, a test execution is a trace of
the concurrent process
\[
Q\parallel[\Sigma] U_F(p).
\]
It is assumed that the events $\efail$ and $\epass$, indicating a verdict
FAIL and PASS for the test execution, are not included in $\Sigma$. Since we
assume that $Q$ is free of livelocks, it is guaranteed that events 
$\efail$ or $\epass$ always become visible, if they are the only events
$U_F(p)/s$ is ready to engage in: if $U_F(p)/s$ can only produce $\epass$ or
$\efail$, the occurrence of these events can never be blocked due to a livelock in $Q$
occurring in the same step of the execution.


The test is
\emph{passed} by the SUT (written $Q\ \pass\ U_F(p)$) if, and only if, {\it
every} execution of $Q\parallel[\Sigma] U_F(p)$ terminates with   event
$\epass$. This can also be  expressed by means of a failures refinement as
defined below.
%
\begin{equation}
\label{eq:passF}
Q\ \pass\ U_F(p) \defs (\epass\then\Stop) \lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma
\end{equation}
%
This type of pass relation is often called \emph{must test}, because every
test execution must end with the $\epass$
event~\cite{Hennessy:1988:ATP:50497}. Note that it is necessary to use the
failures-refinement relation in this condition, and not the trace-refinement
relation:~$(Q\parallel[\Sigma] U_F(p)) \hide \Sigma$ may have  the same
visible traces $\varepsilon$ and $\epass$ as the ``Test Passed
Process'' $(\epass\then\Stop)$. However, the former may nondeterministically
refuse $\epass$, due to a deadlock occurring when a faulty SUT process
executes concurrently with $U_F(p,k,n)$ executing branch (\ref{eq:ufd}),
when guard condition $(k = p\wedge \minhits(n)\neq\varnothing)$ evaluates to $\ist$. 
This is explained further in the next paragraphs.

The specification of $U_F(p,k,n)$ implies that the test always stops after having engaged into a trace $s\in\trc(Q)$ of maximal length $p$ or $p+1$: 
If branch (\ref{eq:ufa})
is the last to be entered, the maximal length of $s$ is $p+1$, and the test execution
stops with $\efail$. If branch (\ref{eq:ufb}) is the last to be entered, the maximal length of $s$ is $p$, and the execution stops with $\epass$. If branch (\ref{eq:ufd})
is the last to be entered, the process either accepts another event
$e$ of some minimal hitting set $H\in\minhits(n)$ with $n = G(P)/s$ according to
Lemma~\ref{lemma:ufproperties}. Then the final length
of $s$ is $p+1$, and the execution terminates with $\epass$. Or the test execution
$(Q\parallel[\Sigma] U_F(p))/s$ deadlocks,  the final length of $s$ is $p$,
and the execution stops without a PASS or FAIL event. Such an execution is also interpreted as FAIL, because it reveals that $(\epass\then\Stop) \not\lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma$.


We observe that the number of possible executions of $Q\parallel[\Sigma]
U_F(p)$ is finite, because the number of traces $s$ with maximal length
$(p+1)$ is finite and the sets $[n]^0$, $(\Sigma - [n]^0)$, and
$\minhits(n)$ are finite. We further recall that $\minhits(n)$ may be
empty, so that the indexed internal choice construct in (\ref{eq:ufd}) 
is undefined. Therefore, the associated guard condition contains the requirement
$\minhits(n)\neq\varnothing$, otherwise this branch cannot be taken,
but branches (\ref{eq:ufa}) or (\ref{eq:ufb}) can be taken in this situation.
%%%\fixme{alcc: Oops. This is undefined in CSP.}

Intuitively speaking, $U_F(p)$ is able to perform any trace $s$ of $P$, up to
a length $p$. If, after having already run through $s\in\trc(P)$ with
$\#s \le p$, an event is accepted by the SUT that is outside the initials of $P/s$
 (recall from Lemma~\ref{lemma:ufproperties} that $[n]^0 = [P/s]^0$ for $U_F(p)/s$),
the test immediately terminates with FAIL-event $\efail$. This is handled by
the branch (\ref{eq:ufa}) of the external choice in the process $U_F(p,\#s,n)$
defined above.

If $P/s$ is the $\Stop$ process or has $\Stop$ as an internal choice,
this is revealed by $\minhits(G(P)/s) = \varnothing$ (recall (\ref{eq:minhitminaccempty}) and
Lemma~\ref{lemma:ufproperties}). 
In this case, the test may terminate successfully (branch (\ref{eq:ufb}) of
the external choice in $U_F(p,\#s,G(P)/s)$). 
If $P/s$ may also nondeterministically engage into events in such a situation, branche 
 (\ref{eq:ufc}) of the test is
simultaneously enabled. If $Q/s$ is able to engage into an event from 
$\Sigma - [P/s]^0$, a test execution exists where $U_F(p,\#s,G(P)/s)$ branches
into (\ref{eq:ifpb}) and produces the $\efail$-event.


If the length of $s$ is still less than $p$, the test accepts any event $e$ from
the initials $[P/s]^0 = [G(P)/s]^0$ and continues recursively as $U_F(p,\#s+1,G(P)/s.e)$ in
branch~(\ref{eq:ufc}), this follows again from  Lemma~\ref{lemma:ufproperties}. 
A test of this type is called \emph{adaptive}, because
it accepts any legal behaviour of the SUT and adapts its consecutive
behaviour to the event selected by the SUT.

Suppose that a test execution has run through a trace 
$s\in\trc(P)$ of length $p$, so that $U_F(p)/s = U_F(p,p,n)$ with $n = G(P)/s$. 
Then,   if
$\minhits(n)\neq \varnothing$, the test changes its behaviour: instead of
offering {\it all} legal events from $[n]^0$ to the SUT, it
nondeterministically chooses a minimal hitting set   $H\in \minhits(n)$ 
and
only offers the events contained in $H$. If the SUT refuses to engage
into any event of $H$, this reveals a violation of failures refinement:
according to Lemma~\ref{lemma:hseta}, a conforming SUT should accept at least
one event of each minimal hitting set in $\minhits(n)$. Therefore, the test
execution
only terminates with  $\epass$, if such an event is accepted by the SUT.

%% =========================================================================
%\subsection{Fault Models and Complete Test Suites}


% =========================================================================
\subsection{A Finite Complete Test Suite for Failures Refinement}


A CSP \emph{fault model} ${\cal F} = (P,\sqsubseteq,{\cal D})$ consists of a
reference process $P$, a conformance relation $\sqsubseteq \in \{\lessdet_T,
\lessdet_F\}$, and a fault domain ${\cal D}$ which is a set of CSP processes
over $P$'s alphabet that may or may not conform to $P$.

A test suite $\TS$ is called \emph{complete} with respect to fault model ${\cal F}$,
if and only if the following conditions are fulfilled.
\begin{description}
\item[1.~Soundness] If $P \sqsubseteq Q$, then $Q$ passes all tests in $\TS$.
\item[2.~Exhaustiveness] If $P \not\sqsubseteq Q$ and $Q\in{\cal D}$,
then $Q$ fails at least one test in $\TS$.
\end{description}
%
In the sequel, we establish the completeness of our test suite which is stated 
in the following main theorem.
%%%\fixme{alcc: I don't think we need a section just for this material.}

 
\begin{theorem}\label{th:failurestest}
Let $P$ be a non-terminating, divergence-free CSP process over alphabet $\Sigma$ whose
normalised transition graph $G(P)$ has $p$ states. Define fault domain ${\cal
D}$ as the set of all divergence-free CSP processes over alphabet $\Sigma$,
whose transition graph has at most $q$ states with $q \ge p$. Then the test
suite
\[
\TS_F = \{ U_F(k)~|~0 \le k < pq  \}\quad\text{$U_F(k)$ specified in (\ref{eq:UFP})}
\]
is complete with respect to ${\cal F} = (P,\lessdet_F,{\cal D})$.
\end{theorem}
%
The proof of the theorem follows from the two lemmas below. The first states
that test suite $\TS_F$ is sound, the second states that the suite is also
exhaustive.
%
\begin{lemma}\label{lemma:mainfsound}
Test suite $\TS_F$ generated from a CSP process $P$, as specified in
Theorem~\ref{th:failurestest}, is passed by every CSP process $Q$ satisfying
$P\lessdet_F Q$.
\end{lemma}
\begin{proof}{~}\newline
{\bf Step~1.} Suppose that $P\lessdet_F Q$, so $P\lessdet_T Q$ and  $Q\ conf\
P$ according to (\ref{eq:failconf}). Since   $\trc(Q)\subseteq \trc(P)$,
any adaptive test $U_F(p)$ running in parallel with $Q$ will always enter the
branches (\ref{eq:ufb}), (\ref{eq:ufc}), or (\ref{eq:ufd}) of the external
choice construction for $U_F(p,k,n)$:  
If $U_F(p,k,n) = U_F(p)/s$ with $s\in\trc(P)$, then Lemma~\ref{lemma:ufproperties}
implies $U_F(p,k,n) = U_F(p,k,G(P)/s)$, so $[n]^0 = [G(P)/s]^0 = [P/s]^0$. As
a consequence, $[Q/s]^0\subseteq [P/s]^0 = [n]^0$, so branch~(\ref{eq:ufa}) can never be
entered in the parallel execution of $Q$ and $U_F(p)$.

\medskip
\noindent
{\bf Step~2.} Sinc $Q\ conf\ P$, Lemma~\ref{lemma:hseta} implies that for all  
$s\in\trc(Q)\cap\trc(P)$, every $H \in \minhits(P/s)$ is a hitting set for
$\minaccs(Q/s)$. 
From Lemma~\ref{lemma:ufproperties} we know that
$U_F(p)/s = U_F(p,k,n)$ with $U_F(p,k,n) = U_F(p,\#s,G(P)/s)$, 
so $\minhits(n) = \minhits(P/s)$. 
Branch (\ref{eq:ufb}) of test $U_F(p,k,n)$ leads always to a
PASS verdict and is taken if $\minhits(n) = \varnothing$. Branch (\ref{eq:ufc}) 
always leads to test continuation without a
verdict. For the last branch, we note that it can only be entered if $\minhits(P/s)
= \minhits(n) \neq\varnothing$. In this case,
any selected minimal hitting set
$H\in\minhits(n)$ has a non-empty intersection with each of the minimal
acceptances of $Q/s$. 
As a consequence, $Q/s$ never blocks when offered
events from $H\in\minhits(n)$, 
and the test terminates with PASS event $\epass$. Note that
this argument requires that $Q$ is free of livelocks, because otherwise the
$\epass$-events might not become visible, due to unbounded sequences of
hidden events performed by $Q$. 
\xbox
\end{proof}
%
\begin{lemma}\label{lemma:mainfexhaustive}
Test suite $\TS_F$ specified in Theorem~\ref{th:failurestest} is exhaustive
for the fault model specified there.
\end{lemma}
\begin{proof}
Consider a process $Q\in{\cal D}$ with $P\not\lessdet_F Q$, According to
(\ref{eq:failconf}), this non-conformance can be caused in two possible ways
corresponding to the cases $P\not\lessdet_T Q$ and $\neg(Q\ conf\ P)$,
respectively:
\begin{description}
\item[Case~1] $\trc(Q)\not\subseteq \trc(P)$
\item[Case~2] There exists a joint trace $s\in\trc(Q)\cap\trc(P)$ and a minimal acceptance $A_Q$
of $\minaccs(Q/s)$, such that
(see Lemma~\ref{lemma:tgtrcref}, (\ref{eq:failrefb})).
\begin{equation}
\label{eq:accsnotcontained}
\forall A_P\in\minaccs(P/s): A_P\not\subseteq A_Q,
\end{equation}
\end{description}
It has to be shown for each of the two cases that at least one test
execution of some $(Q\parallel[\Sigma] U_F(k))$ with $k < pq$ ends with the
   $\efail$-event or without giving any verdict. The latter case is also
interpreted  as FAIL, since then the process $\epass\then\Stop$ is no longer
failures-refined by $(Q\parallel[\Sigma] U_F(k))\hide \Sigma$.

\medskip
\noindent
{\bf Case~1.} Consider a  trace $s.e\in\trc(Q)$ with $s\in\trc(P)$, but
$s.e\not\in\trc(P)$. Such a trace always exists because $\varepsilon$ is a
trace of every process. In this case, $s$ is also a trace of the product
graph $G = G(P)\times G(Q)$ defined in Section~\ref{sec:ntg}, and  
$G/s = (G(P)/s,G(Q)/s)$ holds. The length of $s$ is not known, but from the construction
of $G$,  we know that $G$ has at most $pq$ reachable states, because $G(P)$
has $p$ states, and $G(Q)$ has at most $q$ states. By
Lemma~\ref{lemma:reachproduc}, $(G(P)/s,G(Q)/s)$ can be reached by a trace
$u\in\trc(G)$ of length $\#u < pq$. Now the construction of the transition
function of $G$ implies that $u$ is also a trace of $P$ and $Q$, 
which means that 
$(G(P)/s,G(Q)/s) = (G(P)/u,G(Q)/u)$. Since test
$U_F(pq-1)$ accepts all traces of $P$ up to length $pq-1$, $u$ is also a
trace of this test, and, by construction and by Lemma~\ref{lemma:ufproperties}, 
$U_F(pq-1)/u = U_F(pq-1,\#u,G(P)/u)$. Since
$s.e\not\in\trc(P)$, $e$ is an element of $\Sigma-[P/u]^0 = \Sigma - [G(P)/s]^0$. 
Hence, in at least
one execution, $U_F(pq-1,\#u,G(P)/u)$ executes its first branch (\ref{eq:ufa}) with
this event $e$, so that the test fails. Again, the
assumption of non-divergence of Q is needed for this conclusion.  

\medskip
\noindent
{\bf Case~2.} We note that trace $s$ is again a trace of the product graph
$G$, but we do not know its length. Again, by applying Lemma~\ref{lemma:reachproduc},
we know that the state   $G/s$ can   be reached by a trace
$u\in\trc(Q)\cap\trc(P)$ of maximal length $\#u < pq$. Consider test $U_F(\#
u)$, which satisfies $U_F(\# u)/u = U_F(\#u,\#u,G(P)/u)$, because of Lemma~\ref{lemma:ufproperties}. Test $U_F(\#u)$   always performs
branch (\ref{eq:ufc}) until the trace $u$ has been completely processed.
$U_F(\#u,\#u,G(P)/u)$ may execute branches (\ref{eq:ufa}) or (\ref{eq:ufd})
only:~assumption (\ref{eq:accsnotcontained}) in Case~2 implies that $P/s$ has
at least one non-empty minimal acceptance. From (\ref{eq:minhitminaccempty}) 
we know that this is equivalent to $\minhits(P/s) = \minhits(G(P)/s)\neq\varnothing$, and
we observe that $G(P)/s = G(P)/u$, so $\minhits(G(P)/u)\neq\varnothing$.
As a consequence, branch (\ref{eq:ufb}) cannot be taken because its guard condition
evaluates to $\isf$  for $U_F(\#u,\#u,G(P)/u)$.
The guard condition $(k < p)$ for branch (\ref{eq:ufc}) evaluates
to $\isf$ for $U_F(\#u,\#u,G(P)/u)$, too. If branch (\ref{eq:ufa}) is executed, the
test always fails. If branch (\ref{eq:ufd}) is executed, the test fails for
the execution where a minimal hitting set $H\in\minhits(P/u)$ is chosen
by $U_F(\#u,\#u,G(P)/u)$ that has an empty intersection with the minimal acceptance
$A_Q$ from condition (\ref{eq:accsnotcontained}). The existence of such an
$H$ is guaranteed because of Lemma~\ref{lemma:hseta}. As a consequence, there
exists a test execution   where $Q/u$ selects acceptance $A_Q$ and
$U_F(\#u,\#u,G(P)/u)$ selects $H$. This execution deadlocks in process state
$(Q\parallel[\Sigma]U_F(\# u))/u$, so it cannot produce the $\epass$-event;
this  means that the test fails and concludes the proof. 
\xbox
\end{proof}

% ==========================================================================
