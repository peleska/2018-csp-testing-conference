% ==========================================================================
\section{Finite Complete Test Suites for CSP Failures Refinement}
\label{sec:finitecompletefails}
% ==========================================================================

Here, we define our notion of tests for failures refinement, and then prove
completeness of our suite. Finally, we study to complexity of our approach by
identifying a bound on the number of tests we need in a complete suite.

% ==========================================================================
\subsection{Test Cases for Verifying CSP Failures Refinement}

% -------------------------------------------------------------------------
\subsubsection*{Test Definition and Basic Properties}
In the domain of process algebras, test cases are typically represented
by processes interacting concurrently with the SUT
process~\cite{Hennessy:1988:ATP:50497}. They synchronise with the SUT over its visible events and use some additional events outside the SUT's alphabet to express whether the test execution  passed or failed. %%%, or if no verdict could be obtained.

For a given reference process $P$, its normalised transition graph 
$$
G(P) = ( N, \ii n, \Sigma, t : N\times\Sigma \pfun N, r : N \fun \mathbb{P}\mathbb{P}(\Sigma)),
$$ 
and for each integer $p\ge 0$, we define a
CSP test process for failures refinement as shown below.
%%
%\begin{eqnarray}
%U_F(p) & = & U_F(p,\varepsilon)
%\\
%U_F(p,s) & = & \big( \Extchoice e:(\Sigma - [P/s]^0) @ e \then \efail\then \Stop \big)
%\label{eq:ufa}
%\\ & & \extchoice \nonumber
%\\ & & (\minaccs(P/s) = \{ \varnothing \})    \&   \big( \epass \then \Stop \big)
%\label{eq:ufb}
%\\ & & \extchoice \nonumber
%\\ & & (\#s < p) \& \big( \Extchoice e:[P/s]^0 @ e \then U_F(p,s.e) \big)
%\label{eq:ufc}
%\\ & & \extchoice \nonumber
%\\ & & (\#s = p \wedge \minhits(P/s)\neq\varnothing) \&  \nonumber 
%\\ & & \taba \big( \Intchoice_{H\in\minhits(P/s)} ( \Extchoice e:H @ e \then \epass \then\Stop   )  \big)
%\label{eq:ufd}
%\end{eqnarray}
%
%
\begin{eqnarray}
\label{eq:UFP}
U_F(p) & = & U_F(p,0,\ii n)
\\
U_F(p,k,n) & = & \big(e:(\Sigma - [n]^0)  \then \efail\then \Stop \big)
\label{eq:ufa}
\\ & & \extchoice \nonumber
\\ & & (\minhits(n) =   \varnothing  )    \&   \big( \epass \then \Stop \big)
\label{eq:ufb}
\\ & & \extchoice \nonumber
\\ & & (k < p) \& \big(e:[n]^0   \then U_F(p,k+1,t(n,e) \big)
\label{eq:ufc}
\\ & & \extchoice \nonumber
\\ & & (k = p \wedge \minhits(n)\neq\varnothing) \&  \nonumber 
\\ & & \taba \big( \Intchoice_{H\in\minhits(n)} (e:H   \then \epass \then\Stop   )  \big)
\label{eq:ufd}
\end{eqnarray}
%
Before explaining the intuition behind this test definition in the paragraphs below,
we state its basic properties in the following lemma, to show the relationships between
$U_F(p)$ and the reference process $P$ from which the former has been derived.

\begin{lemma}\label{lemma:ufproperties}
If $s\in\trc(P)$ satisfies $\#s\le p$, then
$s, s.e\in\trc(U_F(p))$ for all $e\in\Sigma$, and the following properties hold.
\begin{eqnarray}
\label{eq:ifpa}
  &  & U_F(p)/s = U_F(p,\#s,G(P)/s)
\\
\label{eq:ifpb}
e\not\in [P/s]^0 & \implies & U_F(p)/s.e = (\efail\then\Stop)
\\
\label{eq:ifpc}
U_F(p)/s = U(p,\# s,n)  & \implies & [n]^0 = [P/s]^0  
\\
\label{eq:ifpd}
U_F(p)/s = U(p,\# s,n)  & \implies & \minhits(n) = \minhits(P/s)
\end{eqnarray}
\end{lemma}
\begin{proof}
We prove (\ref{eq:ifpa}) by induction over the length of $s$. For $\#s = 0$, the statement holds because $U_F(p)$ starts with the initial node $\ii n$ of $G(P)$. Suppose that 
the statement holds for all traces $s$ with length $\# s \le k < p$, so that
$U_F(p)/s = U_F(p,\#s,G(P)/s)$. Now let $s.e$ be a trace of $P$. Then $e\in [P/s]^0$. Since $[G(P)/s]^0 = [P/s]^0$ for all traces $s$ of $P$, we conclude that $e\in  [G(P)/s]^0$,
so $U_F(p)/s = U_F(p,\#s,G(P)/s)$ can engage into $e$ by executing branch (\ref{eq:ufc}).
 Since $t$ is the transition function of $G(P)$ and $e\in  [G(P)/s]^0$, $t(G(P)/s,e)$
 is defined, and $t(G(P)/s,e) = G(P)/s.e$ holds.
This leads to a new recursion  
$U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = U_F(p,\#s+1,G(P)/s.e)$ and proves the induction step.

To prove (\ref{eq:ifpb}), we apply (\ref{eq:ifpa}) to conclude that 
$U_F(p)/s = U_F(p,\#s,G(P)/s)$, because $s$ is a trace of $P$. Noting again that
$[G(P)/s]^0 = [P/s]^0$, this implies that $e\not\in [G(P)/s]^0$, so $U_F(p,\#s,G(P)/s)$
can engage in $e$ by entering branch (\ref{eq:ufa}). The specification of this branch
implies that 
$$
U_F(p)/s.e = U_F(p,\#s,G(P)/s)/e = (\efail\then\Stop).
$$

Statement (\ref{eq:ifpc}) follows trivially from (\ref{eq:ifpa}), because 
$[G(P)/s]^0 = [P/s]^0$ for all traces $s$ of $P$.

Finally, statement (\ref{eq:ifpd}) follows trivially from (\ref{eq:ifpa}), because,
according to (\ref{eq:minhitsGP}),
$\minhits(G(P)/s) = \minhits(P/s)$ for all traces of $P$.
\xbox
\end{proof}

Note that it is not guaranteed for $U_F(p)$ to run through the traces $s, s.e$ specified 
in Lemma~\ref{lemma:ufproperties}, if $\minhits(P/u) = \varnothing$ for some prefix $u$ of $s$: in such a case, $U_F(p)$ may stop with a $\epass$-event by entering branch (\ref{eq:ufb}). Therefore, Lemma~\ref{lemma:ufproperties} just states the existence of
$U_F(p)$-executions $s, s.e$ satisfying the properties stated there.



% --------------------------------------------------------------------------
\subsubsection*{Explanation of the Test Definition}
A test is performed by running $U_F(p)$ concurrently with any SUT process
$Q$, synchronising over $\Sigma$. So, a test execution is a trace of
the concurrent process
\[
Q\parallel[\Sigma] U_F(p).
\]
It is assumed that the events $\efail$ and $\epass$, indicating a verdict
FAIL and PASS for the test execution, are not included in $\Sigma$. Since we
assume that $Q$ is free of livelocks, it is guaranteed that events 
$\efail$ or $\epass$ always become visible, if they are the only events
$U_F(p)/s$ is ready to engage in.


The test is
\emph{passed} by the SUT (written $Q\ \pass\ U_F(p)$) if, and only if, {\it
every} execution of $Q\parallel[\Sigma] U_F(p)$ terminates with   event
$\epass$. This can also be  expressed by means of a failures refinement as
defined below.
%
\begin{equation}
\label{eq:passF}
Q\ \pass\ U_F(p) \defs (\epass\then\Stop) \lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma
\end{equation}
%
This type of pass relation is often called \emph{must test}, because every
test execution must end with the $\epass$
event~\cite{Hennessy:1988:ATP:50497}. Note that it is necessary to use the
failures-refinement relation in this condition, and not the trace-refinement
relation:~$(Q\parallel[\Sigma] U_F(p)) \hide \Sigma$ may have  the same
visible traces $\varepsilon$ and $\epass$ as the ``Test Passed
Process'' $(\epass\then\Stop)$. However, the former may nondeterministically
refuse $\epass$, due to a deadlock occurring when a faulty SUT process
executes concurrently with $U_F(p,k,n)$ executing branch (\ref{eq:ufd}),
because $(k = p\wedge \minhits(P/s)\neq\varnothing)$. 
This is explained further in the next paragraphs.

The specification of $U_F(p,k,n)$ implies that the test always stops after having engaged into a trace $s\in\trc(Q)$ of maximal length $p$ or $p+1$: 
If branch (\ref{eq:ufa})
is the last to be entered, the maximal length of $s$ is $p+1$, and the test execution
stops with $\efail$. If branch (\ref{eq:ufb}) is the last to be entered, the maximal length of $s$ is $p$, and the execution stops with $\epass$. If branch (\ref{eq:ufd})
is the last to be entered, the process either accepts another event
$e$ of some minimal hitting set $H\in\minhits(P/front(s))$. Then the final length
of $s$ is $p+1$, and the execution terminates with $\epass$. Or the test execution
$(Q\parallel[\Sigma] U_F(p))/s$ deadlocks,  the final length of $s$ is $p$,
and the execution stops without a PASS or FAIL event. Such an execution is also interpreted as FAIL, because it reveals that $(\epass\then\Stop) \not\lessdet_F (Q\parallel[\Sigma] U_F(p)) \hide \Sigma$.


We observe that the number of possible executions of $Q\parallel[\Sigma]
U_F(p)$ is finite, because the number of traces $s$ with maximal length
$(p+1)$ is finite and the sets $[n]^0$, $(\Sigma - [n]^0)$, and
$\minhits(n)$ are finite. We further recall that $\minhits(n)$ may be
empty, so that the indexed internal choice construct in (\ref{eq:ufd}) 
is undefined. Therefore, the associated guard condition contains the requirement
$\minhits(P/s)\neq\varnothing$, otherwise this branch cannot be taken,
but branches (\ref{eq:ufa}) or (\ref{eq:ufb}) can be taken in this situation.
%%%\fixme{alcc: Oops. This is undefined in CSP.}

Intuitively speaking, $U_F(p)$ is able to perform any trace $s$ of $P$, up to
a length $p$. If, after having already run through $s\in\trc(P)$ with
$\#s \le p$, an event is accepted by the SUT that is outside the initials of $P/s$
 (recall from Lemma~\ref{lemma:ufproperties} that $[n]^0 = [P/s]^0$ for $U_F(p)/s$),
the test immediately terminates with FAIL-event $\efail$. This is handled by
the branch (\ref{eq:ufa}) of the external choice in the process $U_F(p,s)$
defined above.

If $P/s$ is the $\Stop$ process or has $\Stop$ as an internal choice,
this is revealed by $\minhits(n) = \varnothing$ (recall (\ref{eq:minhitminaccempty}) and
Lemma~\ref{lemma:ufproperties}). 
In this case, the test may terminate successfully (branch (\ref{eq:ufb}) of
the external choice in $U_F(p,s)$). If $P/s$ may also nondeterministically engage into events in such a situation, branches  (\ref{eq:ufa}) and (\ref{eq:ufc}) of the test are
simultaneously enabled.


If the length of $s$ is still less than $p$, the test accepts any event $e$ from
the initials $[P/s]^0 = [G(P)/s]^0$ and continues recursively as $U_F(p,\#s+1,G(P)/s.e)$ in
branch~(\ref{eq:ufc}), this follows again from  Lemma~\ref{lemma:ufproperties}). 
A test of this type is called \emph{adaptive}, because
it accepts any legal behaviour of the SUT and adapts its consecutive
behaviour to the event selected by the SUT.

After having run through a trace of length $p$, and if
$\minhits(P/s)\neq \varnothing$, the test changes its behaviour: instead of
offering {\it all} legal events from $[P/s]^0$ to the SUT, it
nondeterministically chooses a minimal hitting set   $H\in \minhits(G(P)/s)$ 
and
only offers the events contained in $H$. If the SUT refuses to engage
into any event of $H$, this reveals a violation of failures refinement:
according to Lemma~\ref{lemma:hseta}, a conforming SUT should accept at least
one event of each minimal hitting set in $\minhits(P/s)$. Therefore, the test
only terminates with  $\epass$, if such an event is accepted by the SUT.

%% =========================================================================
%\subsection{Fault Models and Complete Test Suites}


% =========================================================================
\subsection{A Finite Complete Test Suite for Failures Refinement}


A CSP \emph{fault model} ${\cal F} = (P,\sqsubseteq,{\cal D})$ consists of a
reference process $P$, a conformance relation $\sqsubseteq \in \{\lessdet_T,
\lessdet_F\}$, and a fault domain ${\cal D}$ which is a set of CSP processes
over $P$'s alphabet that may or may not conform to $P$.

A test suite $\TS$ is called \emph{complete} with respect to fault model ${\cal F}$,
if and only if the following conditions are fulfilled.
\begin{description}
\item[1.~Soundness] If $P \sqsubseteq Q$, then $Q$ passes all tests in $\TS$.
\item[2.~Exhaustiveness] If $P \not\sqsubseteq Q$ and $Q\in{\cal D}$,
then $Q$ fails at least one test in $\TS$.
\end{description}
%
In the sequel, we establish the completeness of our test suite which is stated 
in the following main theorem.
%%%\fixme{alcc: I don't think we need a section just for this material.}

 
\begin{theorem}\label{th:failurestest}
Let $P$ be a divergence-free CSP process over alphabet $\Sigma$ whose
normalised transition graph $G(P)$ has $p$ states. Define fault domain ${\cal
D}$ as the set of all divergence-free CSP processes over alphabet $\Sigma$,
whose transition graph has at most $q$ states with $q \ge p$. Then the test
suite
\[
\TS_F = \{ U_F(k)~|~0 \le k < pq  \}\quad\text{$U_F(k)$ specified in (\ref{eq:UFP})}
\]
is complete with respect to ${\cal F} = (P,\lessdet_F,{\cal D})$.
\end{theorem}
%
The proof of the theorem follows from the two lemmas below. The first states
that test suite $\TS_F$ is sound, the second states that the suite is also
exhaustive.
%
\begin{lemma}\label{lemma:mainfsound}
Test suite $\TS_F$ generated from a CSP process $P$, as specified in
Theorem~\ref{th:failurestest}, is passed by every CSP process $Q$ satisfying
$P\lessdet_F Q$.
\end{lemma}
\begin{proof}{~}\newline
{\bf Step~1.} Suppose that $P\lessdet_F Q$, so $P\lessdet_T Q$ and  $Q\ conf\
P$ according to (\ref{eq:failconf}). Since   $\trc(Q)\subseteq \trc(P)$,
any adaptive test $U_F(p)$ running in parallel with $Q$ will always enter the
branches (\ref{eq:ufb}), (\ref{eq:ufc}), or (\ref{eq:ufd}) of the external
choice construction for $U_F(p,k,n)$:  
If $U_F(p,k,n) = U_F(p)/s$ with $s\in\trc(P)$, then Lemma~\ref{lemma:ufproperties}
implies $U_F(p,k,n) = U_F(p,k,G(P)/s)$, so $[n]^0 = [G(P)/s]^0 = [P/s]^0$. As
a consequence, $[Q/s]^0\subseteq [P/s]^0 = [n]^0$, so branch~(\ref{eq:ufa}) can never be
entered in the parallel execution of $Q$ and $U_F(p)$.

\medskip
\noindent
{\bf Step~2.} Sinc $Q\ conf\ P$, Lemma~\ref{lemma:hseta} implies that for all  
$s\in\trc(Q)\cap\trc(P)$, every $H \in \minhits(P/s)$ is a hitting set for
$\minaccs(Q/s)$. 
From Lemma~\ref{lemma:ufproperties} we know that
$U_F(p)/s = U_F(p,k,n)$ with $U_F(p,k,n) = U_F(p,\#s,G(P)/s)$, 
so $\minhits(n) = \minhits(P/s)$. 
Branch (\ref{eq:ufb}) of test $U_F(p,k,n)$ leads always to a
PASS verdict and is taken if $\minhits(P/s) = \varnothing$. Branch (\ref{eq:ufc}) 
always leads to test continuation without a
verdict. For the last branch, we note that it can only be entered if $\minhits(P/s)
= \minhits(n) \neq\varnothing$. In this case,
any selected minimal hitting set
$H\in\minhits(n)$ has a non-empty intersection with each of the minimal
acceptances of $Q/s$. 
As a consequence, $Q/s$ never blocks when offered
events from $H\in\minhits(n)$, 
and the test terminates with PASS event $\epass$. Note that
this argument requires that $Q$ is free of livelocks, because otherwise the
$\epass$-events might not become visible, due to unbounded sequences of
hidden events performed by $Q$. 
\xbox
\end{proof}
%
\begin{lemma}\label{lemma:mainfexhaustive}
Test suite $\TS_F$ specified in Theorem~\ref{th:failurestest} is exhaustive
for the fault model specified there.
\end{lemma}
\begin{proof}
Consider a process $Q\in{\cal D}$ with $P\not\lessdet_F Q$, According to
(\ref{eq:failconf}), this non-conformance can be caused in two possible ways
corresponding to the cases $P\not\lessdet_T Q$ and $\neg(Q\ conf\ P)$,
respectively:
\begin{description}
\item[Case~1] $\trc(Q)\not\subseteq \trc(P)$
\item[Case~2] There exists a joint trace $s\in\trc(Q)\cap\trc(P)$ and a minimal acceptance $A_Q$
of $\minaccs(Q/s)$, such that
(see Lemma~\ref{lemma:tgtrcref}, (\ref{eq:failrefb})).
\begin{equation}
\label{eq:accsnotcontained}
\forall A_P\in\minaccs(P/s): A_P\not\subseteq A_Q,
\end{equation}
\end{description}
It has to be shown for each of the two cases that at least one test
execution of some $(Q\parallel[\Sigma] U_F(k))$ with $k < pq$ ends with the
   $\efail$-event or without giving any verdict. The latter case is also
interpreted  as FAIL, since then the process $\epass\then\Stop$ is no longer
failures-refined by $(Q\parallel[\Sigma] U_F(k))\hide \Sigma$.

\medskip
\noindent
{\bf Case~1.} Consider a  trace $s.e\in\trc(Q)$ with $s\in\trc(P)$, but
$s.e\not\in\trc(P)$. Such a trace always exists because $\varepsilon$ is a
trace of every process. In this case, $s$ is also a trace of the product
graph $G = G(P)\times G(Q)$ defined in Section~\ref{sec:ntg}. Suppose that
$G/s = (n_P,n_Q)$. The length of $s$ is not known, but from the construction
of $G$,  we know that $G$ has at most $pq$ reachable states, because $G(P)$
has $p$ states, and $G(Q)$ has at most $q$ states. By
Lemma~\ref{lemma:reachproduc}, $(n_P,n_Q)$ can be reached by a trace
$u\in\trc(G)$ of length $\#u < pq$. Now the construction of the transition
function of $G$ implies that $u$ is also a trace of $P$ and $Q$. Since test
$U_F(pq-1)$ accepts all traces of $P$ up to length $pq-1$, $u$ is also a
trace of this test, and, by construction and by Lemma~\ref{lemma:ufproperties}, 
$U_F(pq-1)/u = U_F(pq-1,\#u,G(P)/u)$. Since
$s.e\not\in\trc(P)$, $e$ is an element of $\Sigma-[P/u]^0 = \Sigma - [G(P)/s]^0$. 
Hence, in at least
one execution, $U_F(pq-1,\#u,G(P)/u)$ executes its first branch (\ref{eq:ufa}) with
this event $e$, so that the test fails. Again, the
assumption of non-divergence of Q is needed for this conclusion.  

\medskip
\noindent
{\bf Case~2.} We note that trace $s$ is again a trace of the product graph
$G$, but we do not know its length. Again, by applying Lemma~\ref{lemma:reachproduc},
we know that the state   $G/s$ can   be reached by a trace
$u\in\trc(Q)\cap\trc(P)$ of maximal length $\#u < pq$. Consider test $U_F(\#
u)$, which satisfies $U_F(\# u)/u = U_F(\#u,\#u,G(P)/u)$, because of Lemma~\ref{lemma:ufproperties}. This process   always performs
branch (\ref{eq:ufc}) until the trace $u$ has been completely processed.
$U_F(\#u,\#u,G(P)/u)$ may execute branches (\ref{eq:ufa}) or (\ref{eq:ufd})
only:~assumption (\ref{eq:accsnotcontained}) in Case~2 implies that $P/s$ has
at least one non-empty minimal acceptance. From (\ref{eq:minhitminaccempty}) 
we know that this is equivalent to $\minhits(P/s) = \minhits(G(P)/s)\neq\varnothing$.
As a consequence, branch (\ref{eq:ufb}) can never be taken because its guard condition
evaluates to $\isf$  for $U_F(\#u,\#u,G(P)/u)$.
Moreover, the guard condition $(k < p)$ for branch (\ref{eq:ufc}) evaluates
to $\isf$ for $U_F(\#u,\#u,G(P)/u)$, too. If branch (\ref{eq:ufa}) is executed, the
test always fails. If branch (\ref{eq:ufd}) is executed, the test fails for
the execution where a minimal hitting set $H\in\minhits(P/u)$ is chosen
by $U_F(\#u,\#u,G(P)/u)$ that has an empty intersection with the minimal acceptance
$A_Q$ from condition (\ref{eq:accsnotcontained}). The existence of such an
$H$ is guaranteed because of Lemma~\ref{lemma:hseta}. As a consequence, there
exists a test execution   where $Q/u$ selects acceptance $A_Q$ and
$U_F(\#u,\#u,G(P)/u)$ selects $H$. This execution deadlocks in process state
$(Q\parallel[\Sigma]U_F(\# u))/u$, so it cannot produce the $\epass$-event;
this  means that the test fails and concludes the proof. 
\xbox
\end{proof}

% ==========================================================================
\subsection{Complexity Considerations}
\label{sec:complexity}

As can be seen from the specification of the test cases $U_F(k)$, the number of
executions ending in a $\epass$-event corresponds to the number $\ell$ of traces $s$
of $P$ with length equal to\footnote{In this estimation, we disregard
the case where the test
terminates earlier due to entering branch (\ref{eq:ufb}).} $k$,
multiplied by the number $h$ of minimal hitting sets in
$\minhits(P/s)$. 



% -------------------------------------------------------------------------
\subsubsection*{Estimation of $\ell$}
The first factor $\ell$
has worst-case upper bound $\ell\le |\Sigma|^k$. As an example, where this upper bound 
is really met, consider the reference process
\[
RUN(\Sigma) = e:\Sigma \then RUN(\Sigma)
\]
The normalised transition graph of this process has a single state, and its initials
are $[RUN(\Sigma)]^0 = \Sigma$. Therefore, the associated test process $U_F(k)$ can 
never enter branches (\ref{eq:ufa}) and (\ref{eq:ufb}), but there are exactly 
$|\Sigma|^k$ different traces of length $k$ exercising branch (\ref{eq:ufc})
for each of their events.

% -------------------------------------------------------------------------
\subsubsection*{Estimation of $h$}
Given a set $\minaccs(P/s) = \{ A_1,\dots, A_\alpha \}$ of   minimal
acceptances, the cardinality $h$ of $\minhits(P/s)$ is maximal for the case
where all $A_i$ are disjoint. In this case,  $h~~=~~|\minhits(P/s)|~~=~~
\prod_{i=1}^\alpha|A_i|$. To find an upper bound for $h$, we use the result
that we prove in the following lemma.
%
\begin{lemma}\label{lemma:minhitmax}
Let $n\ge 2$ be any positive integer. We call a sequence
%
$$0 < a_1\le a_2\le \ldots\le  a_{\alpha}, a_i\in \mathbb{N}, i=1,\dots, \alpha$$
%
a partition of $n$, if $n=\Sigma_{i=1}^{\alpha}a_i$. Define
%
$$p(n)=\begin{cases} 3^k &\text{if}\,\, n=3k\\ 2^2\cdot 3^{k-1} &\text{if}\,\, n=3k+1\\2\cdot 3^{k} &\text{if}\,\, n=3k+2\end{cases}$$
Then  $$p(n)=\max\big\{\prod_{i=1}^{\alpha}a_i~|~n=\Sigma_{i=1}^{\alpha}a_i,\ a_i,
\alpha\in \mathbb{N}\big\}.$$
%
\end{lemma}
\begin{proof}
Let $n\ge 2$. Obviously, \begin{equation}\label{eq:1} n\le
p(n).\end{equation} Define $\pi(n)$ to be the following partition  of $n$:
%
$$\pi(n)=\begin{cases} \underbrace{3,\ldots,3}_{k\text{ times}}  &\text{if}\,\, n=3k\\ 2,2,\underbrace{3,\ldots,3}_{k-1\text{ times}}  &\text{if}\,\, n=3k+1\\2,\underbrace{3,\ldots,3}_{k\text{ times}}  &\text{if}\,\, n=3k+2\end{cases}$$
%
Then the product of the numbers in $\pi(n)$ equals  $p(n)$. In the remainder
of the proof we have to show that $p(n)$ is really maximal in the sense of
the lemma.

Since the number of partitions of a given $n$ is finite,
%
$$\text{max}\{\prod_{i=1}^{\alpha}a_i~|~n=\Sigma_{i=1}^{\alpha}a_i, a_i\in \mathbb{N}\}$$
%
exists. Let $a_1, \ldots , a_{\alpha}$ be any partition of $n\ge 2$ with
maximal product. Then, obviously,  $a_i>1$ for all $i=1,\dots,\alpha$.
Suppose there is some $a_j$, $1\le j\le \alpha$, with $a_j>3$. Then
from~(\ref{eq:1}) we have
$$\prod_{i=1}^{\alpha}a_i\le a_1\cdot a_{j-1}\cdot p(a_j)\cdot a_{j+1}\ldots\cdot a_{\alpha}.$$
Hence we can replace $a_j$ by $\pi(a_j)$, and the new partition has  a
product value which is not less then the original partition $a_1, \ldots ,
a_{\alpha}$. This process can be repeated, until every $a_i$ in the resulting
partition is either 2 or 3. Hence there exists a partition of $n$ with
maximal product, such that every term is $2$ or $3$. Since $6=2+2+2=3 + 3$
and $2^3< 3^2$, the number of $2$'s in such a maximal partition is less than
$3$. Let $a_1\le a_2\le \ldots\le  a_{\alpha}$ with $a_i\in \{2,3\},
i=1,\dots,\alpha$, be a partition of $n$ with maximal product. Let $k_1\le 2$
be the number of terms equal $2$ and $k_2$ be the number of terms equal $3$.
Every $n\ge 2$ can be represented by $n=2k_1+3k_2$, $n\equiv 2k_1 (\mod 3)$
with $k_1\le 2$, and $\prod_{i=1}^{\alpha}a_i=2^{k_1}\cdot 3^{k_2}$. We have

\begin{align*}k_1&=\begin{cases} 0 &\text{if}\,\, n=3k\\ 2 &\text{if}\,\, n=3k+1\\1 &\text{if}\,\, n=3k+2\end{cases}\\
 k_2&=\begin{cases} k &\text{if}\,\, n=3k\\ k-1 &\text{if}\,\, n=3k+1\\k &\text{if}\,\, n=3k+2\end{cases}\\
\prod_{i=1}^{\alpha}a_i&=\begin{cases} 3^k &\text{if}\,\, n=3k\\ 2^2\cdot 3^{k-1} &\text{if}\,\, n=3k+1\\2\cdot 3^{k} &\text{if}\,\, n=3k+2\end{cases}\end{align*}
This proves the lemma.
\xbox
\end{proof}
%
From Lemma~\ref{lemma:minhitmax}, we conclude that
$$h=\begin{cases}
3^{\lfloor\frac{|\Sigma|}{3}\rfloor} &\text{if}\  |\Sigma|~~\equiv~~0 \mod 3\\
3^{\lfloor\frac{|\Sigma|}{3}\rfloor}  + 3^{\lfloor\frac{|\Sigma|}{3}\rfloor-1}&\text{if}\ |\Sigma|~~\equiv~~1\mod 3\\
2\cdot 3^{\lfloor\frac{|\Sigma|}{3}\rfloor} &\text{if}\ |\Sigma|~~\equiv~~2 \mod 3
\end{cases}
$$
%
We note that $h$ is significantly smaller than $2^{|\Sigma|}-1$, this can
also be intuitively motivated by the fact that  for every $H\in
\minhits(P/s)$, all of its true subsets and true supersets are {\it not}
contained in $\minhits(P/s)$.

From Theorem~\ref{th:failurestest}, we need to execute the tests $U_F(k)$ for
$k = 0,\dots,(pq-1)$; this results in a worst-case bound defined below, where
we use the formula for the sum of the geometric progression.
%
\[
h\cdot \big( \frac{1-|\Sigma|^{pq}}{1-|\Sigma|} \big),\
 \text{or, asymptotically,}\  O(3^{\lfloor\frac{|\Sigma|}{3}\rfloor}\cdot|\Sigma|^{(pq-1)}).
 \]
%
From Lemma~\ref{lemma:hseta} we know that the worst-case bound for $h$
above cannot be further improved, since the full collection of minimal
hitting sets needs to be checked to verify $conf$. The
authors of~\cite{Hennessy:1988:ATP:50497} and
\cite{DBLP:conf/icfem/CavalcantiG07} suggest to test {\it every} non-empty
subset of $\Sigma$ whose events cannot be completely refused in a given
process state of the reference model; this leads to a worst-case estimate of
$2^{|\Sigma|}-1$ for the number of different sets to be offered to the SUT in
the last step of the test execution, so our approach reduces the number of
test executions in comparison
to~\cite{Hennessy:1988:ATP:50497,DBLP:conf/icfem/CavalcantiG07}.



% -------------------------------------------------------------------------
\subsubsection*{Upper Bound $pq$ for Number of Test Cases}

According to Theorem~\ref{th:failurestest}, the tests $U_F(k)$ need to be executed for 
$k = 0,\dots,pq-1$ to guarantee completeness. This means that the SUT is verified 
with test traces up to, and including, length $pq$. It is interesting to  investigate
whether this maximal length is really necessary, or whether one could elaborate
alternative complete test strategies where the SUT is tested with shorter traces only. 
Indeed, an example  presented in~\cite[Exercise~5]{PeleskaHuangLectureNotesMBT} 
shows that when testing for equivalence of deterministic FSMs, it is sufficient to
test the SUT with traces of significantly shorter length.

The following example, however, shows that the maximal length $pq$ is really required 
when testing for refinement.
\begin{example}\label{ex:pq}
Consider the CSP reference process $P$ and an erroneous implementation $Q$ specified
as follows.
\begin{eqnarray*}
P & = & a \then P_1 \intchoice b \then P_1 \intchoice c \then P_1
\\
P_1 & = & a \then P \extchoice b\then P
\\ & &  \\
Q & = & a\then Q_1 \extchoice b\then Q_1
\\
Q_1 & = & a\then Q_2 \extchoice b\then Q_2
\\
Q_2 & = & a\then Q \intchoice b\then Q
\end{eqnarray*}
Obviously, $P$'s normalised transition graph has 2 nodes, 
while $Q$'s graph has 3.
It is easy to see (and can be checked with FDR4) that $P\lessdet_T Q$, but 
$\neg(P\lessdet_F Q)$. Furthermore, it can also be shown using the FDR4 tool that
the ``test passed condition'' 
\[
(\epass\then\Stop) \lessdet_F (Q\parallel[\Sigma] U_F(k))\hide \Sigma
\]
holds for $U_F(0),\dots,U_F(4)$, but fails for $U_F(5)$. This means that the
non-conformance of $Q$ cannot be detected by any test trace of length 
less or equal to 5, but is revealed (as expected from Theorem~\ref{th:failurestest})
by a trace of length 6, because the last event offered by the test $U_F(5)$ is 
refused by $Q$.
\xbox
\end{example}
%
Generalising Example~\ref{ex:pq}, it can be shown that for any pair 
$2\le p,q \in\mathbb{N}$,  
there exist reference processes with $p$ states
and implementation processes with $q$ states, such that 
a violation of the trace refinement property
can only be detected with a trace of length $pq$. This is proven in the following 
theorem.

\begin{theorem}
Let $2\le p,q \in\mathbb{N}$. Then there exists a reference process $P$ and an
implementation process $Q$ with the following properties.
\begin{enumerate}
\item $G(P)$ has $p$ states.
\item $G(Q)$ has $q$ states.
\item $P\not\lessdet_T Q$.
\item $\forall s\in\trc(Q): \#s < pq\implies s\in\trc(P)$.
\end{enumerate}
As a consequence, the upper bound $pq$ for the length of traces to be tested when checking for failures refinement cannot be reduced without losing the test suite's completeness property.
\end{theorem}
\begin{proof}
Given $2\le p,q \in\mathbb{N}$, define reference process $P$ and implementation process $Q$
over alphabet $\Sigma =\{ a,b\}$ as follows.
\begin{eqnarray*}
P & = &  P(0) 
\\
P(k) & = & \big( a \then P(k) \big) \extchoice (k < p-1) \& \big( b \then P(k+1)\big)
\\ 
Q & = & Q(0)
\\
Q(k) & = & (k < q-1) \& \big( a \then Q(k+1)    \big) \extchoice 
( k = q-1)\& \big( a\then Q(0) \extchoice b\then Q(0)  \big)
\end{eqnarray*}
Using regular expression notation, the traces of $P$ can be specified as
\[
\trc(P) = \prefs\big(  (a^*b)^{p-1}a^* \big),
\]
where $\prefs(M)$ denotes the set of all prefixes of traces in $M\subset\Sigma^*$, 
including the traces of $M$ themselves.
The traces of $Q$ can be specified by
\[
\trc(Q) = \prefs\big( (a^{q-1}(a|b))^*  \big).
\]
It is easy to see that $\trc(Q)\not\subseteq\trc(P)$; 
for example, the trace $(a^{q-1}b)^p$ is in
$\trc(Q)\setminus\trc(P)$.

Let $s \in\trc(Q)$ be any trace of length $\#s = pq-1$. Then $s$ can be represented 
by $s = (a^{q-1}(a|b))^{p-1}a^{q-1} \in \prefs\big( (a^{q-1}(a|b))^*  \big)$. 
Then $s$ is also an element of $\trc(P)$, because $(a^{q-1}(a|b))^{p-1}a^{q-1}$ 
is also contained in $\prefs\big(  (a^*b)^{p-1}a^* \big)$: this is easy to see, since
$\prefs\big(  (a^*b)^{p-1}a^* \big)$ contains all finite sequences of $a$-events, 
where at most $p-1$ events $b$ have been inserted.
\xbox
\end{proof}

It is discussed in Section~\ref{sec:conc} how the number of test traces to be executed 
by complete test suites for failures refinement   can still be reduced {\it without} reducing 
the maximal length.


% ==========================================================================
